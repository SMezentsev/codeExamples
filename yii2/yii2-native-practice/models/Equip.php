<?php

namespace app\modules\itrack\models;

class Equip extends User
{
    
    
    const TYPE_ALL = 0;
    const TYPE_ZEBRA = 1;
    const TYPE_OCS = 2;
    const TYPE_SICPA = 3;
    const TYPE_OCS_RUS = 4;
    
    public static $equipTypes = [
        self::TYPE_ALL     => "Общий",
        self::TYPE_ZEBRA   => "Принтер ZEBRA",
        self::TYPE_OCS     => "OCS",
        self::TYPE_SICPA   => 'SICPA',
        self::TYPE_OCS_RUS => "OCS-RUS",
    ];
    static $auditOperation = AuditOperation::OP_EQUIP;
    public $type;
    public $ip;
    public $data;
    public $zpl;
    
    static function getZebraIp($object)
    {
        $ip = "";
        if (isset(\Yii::$app->params['zebra'])) {
            if (isset(\Yii::$app->params['zebra']['ip'])) {
                $ip = \Yii::$app->params['zebra']['ip'];
            }
            if (isset(\Yii::$app->params['zebra']['objects']) && isset(\Yii::$app->params['zebra']['objects'][$object])) {
                $ip = \Yii::$app->params['zebra']['objects'][$object];
            }
        }
        
        return $ip;
    }
    
    public static function find()
    {
        return parent::find()
            ->where('deleted_at is null')
            ->andWhere('is_equip = true');
    }
    
    public function behaviors()
    {
        return [['class' => \app\modules\itrack\components\AuditBehavior::class]];
    }
    
    public function init()
    {
//        parent::init(); // TODO: Change the autogenerated stub
        $this->on(self::EVENT_BEFORE_VALIDATE, function ($event) {
            $event->sender->zpl = '';
            if (\Yii::$app->request->isPut) {
                function parse_raw_http_request(array &$a_data)
                {
                    // read incoming data
                    $input = file_get_contents('php://input');
                    
                    // grab multipart boundary from content type header
                    preg_match('/boundary=(.*)$/', $_SERVER['CONTENT_TYPE'], $matches);
                    $boundary = $matches[1];
                    
                    // split content by boundary and get rid of last -- element
                    $a_blocks = preg_split("/-+$boundary/", $input);
                    array_pop($a_blocks);
                    
                    // loop data blocks
                    foreach ($a_blocks as $id => $block) {
                        if (empty($block)) {
                            continue;
                        }
                        
                        // you'll have to var_dump $block to understand this and maybe replace \n or \r with a visibile char
                        // parse uploaded files
                        if (strpos($block, 'application/octet-stream') !== false) {
                            // match "name", then everything after "stream" (optional) except for prepending newlines
                            preg_match("/\bname=\"([^\"]*)\".*stream[\n|\r]+([^\n\r].*)?$/s", $block, $matches);
                        } // parse all other fields
                        else {
                            // match "name" and optional value in between newline sequences
                            preg_match('/\bname=\"([^\"]*)\".*?[\n|\r]+([^\n\r].*)?\r$/s', $block, $matches);
                        }
                        $a_data[$matches[1]] = $matches[2];
                    }
                }
                
                $a_data = [];
                parse_raw_http_request($a_data);
                if (isset($a_data["file"])) {
                    $event->sender->zpl = $a_data["file"];
                }
                if (isset($a_data["login"])) {
                    $event->sender->login = $a_data["login"];
                }
                if (isset($a_data["type"])) {
                    $event->sender->type = $a_data["type"];
                }
                if (isset($a_data["ip"])) {
                    $event->sender->ip = $a_data["ip"];
                }
                if (isset($a_data["data"])) {
                    $event->sender->data = $a_data["data"];
                }
                if (isset($a_data["object_uid"])) {
                    $event->sender->object_uid = $a_data["object_uid"];
                }
//                if(empty($event->sender->zpl))
//                    throw new \yii\web\BadRequestHttpException('Некорректный zpl файл');
            }
            if (\Yii::$app->request->isPost) {
                $f = \yii\web\UploadedFile::getInstanceByName('file');
                if (!empty($f->tempName)) {
                    $event->sender->zpl = file_get_contents($f->tempName);
                }
            }
        });
        $this->on(self::EVENT_BEFORE_INSERT, function ($event) {
            $this->updatePassword();
            $event->sender->is_equip = true;
            if ($this->type != self::TYPE_ZEBRA) {
                $this->zpl = '';
            }
            $event->sender->params = serialize(["type" => $this->type, "ip" => $this->ip, "data" => $this->data, "zpl" => $this->zpl]);
        });
        $this->on(self::EVENT_BEFORE_UPDATE, function ($event) {
            if (SERVER_RULE == SERVER_RULE_SKLAD) {
                //мы на складе
                $objectIds = \Yii::$app->getModule('sklad')->objectIds;
                if (!in_array($this->object_uid, array_keys($objectIds))) {
                    throw new \yii\web\BadRequestHttpException('Нельзя редактирвать данное оборудование на этом сервере');
                }
            } else {
                //мы на мастере
                $object = Facility::findOne(['id' => $this->object_uid]);
                if (!empty($object) && $object->has_server) {
                    throw new \yii\web\BadRequestHttpException('Нельзя редактирвать данное оборудование на этом сервере');
                }
            }
            $this->updatePassword();
            $event->sender->is_equip = true;
            if ($this->type != self::TYPE_ZEBRA) {
                $this->zpl = '';
            }
            $event->sender->params = serialize(["type" => $this->type, "ip" => $this->ip, "data" => $this->data, "zpl" => $this->zpl]);
        });
    }
    
    public function save($runValidation = true, $attributeNames = null)
    {
        //фича если не прислали групповой код, считаем это повторным взвешиванием
        try {
            $ret = parent::save($runValidation, $attributeNames);
        } catch (\yii\web\BadRequestHttpException $ex) {
            throw new \yii\web\BadRequestHttpException($ex->getMessage());
        } catch (\Exception $exc) {
            throw new \yii\web\BadRequestHttpException('Ошибка сохранения, обратитесь к администраторам');
        }
        
        return $ret;
    }
    
    public function afterValidate()
    {
        if ($this->hasErrors()) {
            throw new \yii\web\BadRequestHttpException('Ошибка сохранения: ' . implode(", ", array_map(function ($item) {
                    return is_array($item) ? array_pop($item) : $item;
                }, $this->getErrors())));
        }
        
        return parent::afterValidate();
    }
    
    public function rules()
    {
        return array_merge(
            parent::rules(),
            [
                [['type', 'ip', 'fio', 'login', 'zpl', 'data'], 'safe'],
                ['type', 'integer'],
                ['type', 'in', 'range' => array_keys(self::$equipTypes)],
                [['login'],
                    'unique',
                    'filter'  => function ($query) {
                        $query->where(['login' => $this->login]);
                        $query->andFilterWhere(['<>', 'id', $this->id]);
                        
                        return $query;
                    },
                    'message' => 'Данный логин уже занят'],
//            [['login'], 'unique', 'message' => 'Оборудование с таким логином уже создано', 'when' => function($model) {
//                            return $model->isAttributeChanged('login');
//                        }],
            ]
        );
    }
    
    public function createGeneration($values)
    {
        $m = null;
        
        switch ($this->type) {
            case Equip::TYPE_OCS_RUS:
            case Equip::TYPE_OCS:
                $ocs = new Ocs();
                $ocs->load($values, '');
                $ocs->save(false);
                $ocs->refresh();
                $m = Ocs::createGenerations($ocs->id);
                break;
            case Equip::TYPE_SICPA:
                $sicpa = new Sicpa();
                $sicpa->load($values, '');
                $sicpa->save(false);
                $sicpa->refresh();
                $m = Sicpa::createGenerations($sicpa->id);
                break;
            case Equip::TYPE_ALL:
                $values["equip_uid"] = null;
                $gen = new Generation();
                $gen->scenario = 'default';
                $gen->load($values, '');
                if ($gen->save(false)) {
                    $gen->refresh();
                    $m = $gen;
                }
                break;
        }
        
        return $m;
    }
    
    public function scenarios()
    {
        $ret = parent::scenarios();
        $ret['default'][] = 'type';
        $ret['default'][] = 'ip';
        $ret['default'][] = 'zpl';
        
        return $ret;
    }
    
    public function fields()
    {
        return array_merge(parent::fields(),
            [
                'zpl',
                'ip',
                'data',
                'type',
                'typeName' => function () {
                    $v = "";
                    if (isset(self::$equipTypes[$this->type])) {
                        $v = self::$equipTypes[$this->type];
                    }
                    
                    return $v;
                },
            ]
        );
    }
    
    public function afterFind()
    {
        try {
            $a = unserialize($this->params);
        } catch (Exception $ex) {
        }
        if (is_array($a)) {
            $this->type = $a["type"] ?? self::TYPE_ALL;
            $this->ip = $a["ip"] ?? '';
            $this->data = $a["data"] ?? '';
            $this->zpl = $a["zpl"] ?? '';
        } else {
            $this->type = self::TYPE_ALL;
        }
    }
    
}
